# OsteoApp - Cursor AI Rules

## Project Overview

OsteoApp is a **Kotlin Multiplatform** application for osteopaths to manage patients and their clinical visits. The application is primarily designed for **Desktop** use (with future mobile platform support) using **Compose Multiplatform** for the UI layer.

### Key Objectives
- **Patient Management**: Complete patient records with demographics, medical history, and clinical data
- **Visit Tracking**: Detailed visit records including symptoms evaluation, treatments performed, and follow-up plans
- **Data Visualization**: Clear, intuitive interface for viewing patient data and visit history
- **Efficient Data Entry**: Streamlined forms and workflows to facilitate quick data input during consultations

## Technical Stack

### Core Technologies
- **Kotlin Multiplatform**: Shared business logic across platforms
- **Compose Multiplatform**: UI framework for consistent cross-platform interface
- **Primary Target**: Desktop application (Windows, macOS, Linux)
- **Future Targets**: Android and iOS mobile applications

### Architecture Pattern
- **MVI Pattern**: Use Model-View-Intent pattern with ViewModels, Events, States, and SideEffects
- **Clean Architecture**: Implement domain layer with Use Cases and Repository pattern when needed
- **Unidirectional Data Flow**: State changes flow through ViewModels using events and side effects

### Data Management
- **Local Database**: Realm DB for offline-first approach with reactive data flow
- **Data Format**: Hybrid approach using Realm objects for structured data and JSON for complex nested data
- **Backup/Export**: JSON format for data portability and backup
- **Schema Versioning**: Built-in migration support for future updates

## Data Structure Requirements

### Patient Information Schema
Based on the provided clinical form template, the application must handle:

#### 1. Demographics & Basic Info
- Personal details (name, surname, birth date, fiscal code, contacts)
- Address information (structured object)
- Privacy consents and legal information
- Parent information (for minors) - **âœ… IMPLEMENTED** with full CRUD operations
- Referring physician details

#### 2. Clinical History
- Drug allergies, chronic conditions (diabetes, hypertension, etc.)
- Lifestyle factors (work type, physical activity, smoking habits)
- Current medications and treatments
- Anthropometric measurements (height, weight, BMI)
- Cranial indices (specific to osteopathic practice)

#### 3. Visit Records
- **Chief Complaint**: Primary and secondary reasons for consultation
- **Pain Assessment**: VAS scale, pain characteristics, triggers, relieving factors
- **Treatments Performed**: Detailed treatment techniques, duration, recommendations
- **Systems Review**: Comprehensive evaluation across 13 body systems:
  - Cranial, Respiratory, Cardiovascular, Gastrointestinal
  - Urinary, Reproductive, Psycho-neuro-endocrine-immune
  - Skin/Nails, Metabolism, Lymph nodes, Musculoskeletal, Nervous

#### 4. Clinical History
- Previous interventions and traumas
- Diagnostic tests and results
- Pediatric history (when applicable)

### Data Scalability Requirements
- **Flexible Schema**: Support for adding new sections without database migrations
- **Versioned Structures**: Schema versioning for backward compatibility
- **Modular Design**: Each body system as a separate, pluggable module
- **Complex Data Types**: Support for arrays, nested objects, and conditional fields

## Development Guidelines

### Code Structure
```
src/
â”œâ”€â”€ commonMain/
â”‚   â”œâ”€â”€ data/
â”‚   â”‚   â”œâ”€â”€ models/        # Data classes and entities
â”‚   â”‚   â”œâ”€â”€ repositories/  # Data access layer
â”‚   â”‚   â””â”€â”€ database/      # Database setup and DAOs
â”‚   â”œâ”€â”€ domain/
â”‚   â”‚   â”œâ”€â”€ usecases/      # Business logic
â”‚   â”‚   â””â”€â”€ entities/      # Domain models
â”‚   â””â”€â”€ presentation/
â”‚       â”œâ”€â”€ screens/       # Compose UI screens
â”‚       â”œâ”€â”€ components/    # Reusable UI components
â”‚       â””â”€â”€ viewmodels/    # Presentation logic
â”œâ”€â”€ desktopMain/          # Desktop-specific implementations
â”œâ”€â”€ androidMain/          # Android-specific (future)
â””â”€â”€ iosMain/             # iOS-specific (future)
```

### UI/UX Requirements
- **Desktop-First Design**: Optimized for keyboard and mouse interaction
- **Form-Heavy Interface**: Efficient data entry with validation and auto-completion
- **Search and Filter**: Quick patient lookup and visit history filtering
- **Responsive Layout**: Adaptable to different screen sizes and orientations
- **Accessibility**: Support for screen readers and keyboard navigation

### Key Features to Implement
1. **Patient Management** - **âœ… CORE FEATURES IMPLEMENTED**
   - âœ… Add/edit patient records with comprehensive forms
   - âœ… Search and filter patients
   - âœ… Patient history overview with detailed information
   - âœ… Parent information management for minors
   - âœ… Anthropometric measurements and privacy consents

2. **Visit Management** - **âœ… CORE FEATURES IMPLEMENTED**
   - âœ… Create new visit records with comprehensive forms
   - âœ… Visit details screen with patient information display
   - âœ… Delete visit functionality with confirmation dialog
   - âœ… Edit visit functionality with proper MVI pattern and ID-based navigation
   - âœ… Database integration with Realm DB and reactive data flow
   - âœ… Domain layer with use cases and repository pattern
   - âœ… Date format handling (ISO â†” Italian conversion)
   - ðŸ“‹ Multi-step form for comprehensive data entry (planned)
   - ðŸ“‹ Template-based visit types (planned)
   - ðŸ“‹ Treatment planning and follow-up scheduling (planned)

3. **Data Visualization** - **ðŸ“‹ PLANNED**
   - Patient timeline view
   - Treatment progress tracking
   - Statistical dashboards for practice management

4. **Data Management** - **âœ… BASIC FEATURES IMPLEMENTED**
   - âœ… Realm DB integration with reactive data flow
   - âœ… Data validation and error handling
   - ðŸ“‹ Import/export functionality (planned)
   - ðŸ“‹ Backup and restore capabilities (planned)

## Coding Conventions

### Naming Conventions
- **Package Names**: lowercase, descriptive (`com.osteoapp.data.models`)
- **Class Names**: PascalCase (`PatientRepository`, `VisitViewModel`)
- **Function Names**: camelCase (`savePatient`, `getVisitHistory`)
- **Variable Names**: camelCase (`patientId`, `visitDate`)
- **Constants**: SCREAMING_SNAKE_CASE (`MAX_PATIENTS_PER_PAGE`)

### Language and Localization
- **Field Names in Italian**: Database fields and JSON keys should use Italian terms to match the osteopath's workflow
- **UI Labels**: Support for Italian language with potential for internationalization
- **Code Comments**: English for technical documentation, Italian for business logic explanations

### Data Handling
- **Null Safety**: Leverage Kotlin's null safety features extensively
- **Immutable Data**: Prefer data classes and immutable structures
- **Validation**: Implement comprehensive data validation at multiple layers
- **Error Handling**: Robust error handling with user-friendly messages

## Performance Requirements
- **Offline-First**: Application must work without internet connection
- **Fast Search**: Patient search results should appear within 100ms
- **Efficient Storage**: Optimize database queries and minimize storage footprint
- **Responsive UI**: Maintain 60fps performance during data entry and navigation

## Security and Privacy Requirements
- **Local Storage**: All patient data stored locally on the practitioner's device
- **Data Encryption**: Encrypt sensitive patient information at rest
- **Access Control**: Password protection for application access
- **Audit Trail**: Log data modifications for compliance tracking
- **GDPR Compliance**: Support for data export and deletion requests

## Testing Strategy
- **Unit Tests**: Comprehensive coverage for business logic and data models
- **Integration Tests**: Database operations and data synchronization
- **UI Tests**: Critical user workflows and form validation
- **Performance Tests**: Database query performance and UI responsiveness

## Development Priorities
1. **Phase 1**: Core patient and visit management (Desktop) - **âœ… COMPLETED**
   - âœ… Patient management fully implemented
   - âœ… Visit management core features implemented
2. **Phase 2**: Advanced visit features and system improvements - **âœ… COMPLETED**
   - âœ… Delete visit functionality with confirmation dialog
   - âœ… Edit visit functionality with proper MVI pattern and ID-based navigation
   - âœ… Date format handling (ISO â†” Italian conversion)
   - âœ… Enhanced data validation and error handling
   - ðŸ“‹ Search and filtering (next priority)
3. **Phase 3**: Extended visit information (apparatus, treatments, evaluations) - **ðŸ“‹ PLANNED**
   - Comprehensive clinical data models
   - Multi-step visit forms
   - Treatment documentation
4. **Phase 4**: Advanced features and mobile platform support - **ðŸ“‹ PLANNED**
   - Advanced analytics
   - Mobile platform support
   - Data migration and backup

## Current Status (January 2025)
- **Patient Management**: âœ… **COMPLETE** - Full CRUD operations, parent information, clinical history
- **Visit Management**: âœ… **COMPLETE** - Create visits, view details, delete visits, edit visits, database integration, domain layer
- **Database Integration**: âœ… **COMPLETE** - Realm DB with reactive data flow
- **UI/UX**: âœ… **COMPLETE** - Material 3 design with Italian localization
- **Data Validation**: âœ… **COMPLETE** - Comprehensive validation with error handling
- **MVI Architecture**: âœ… **COMPLETE** - Proper Model-View-Intent pattern implementation

## Next Development Phase: Phase 3 - Patient Screen Architecture Refactoring

### **ðŸš¨ CRITICAL: Patient Screen Architecture Issues**

**Current Problem**: The `PatientDetailsScreen` uses an inconsistent architecture compared to visits:
- **Visits**: Separate screens (`VisitDetailsScreen` + `EditVisitScreen`) âœ… **GOOD**
- **Patients**: Single complex screen with tabs and mixed ViewModels âŒ **PROBLEMATIC**

**Issues with Current Implementation**:
1. **Architectural Inconsistency**: Different patterns for patients vs visits
2. **Complex State Management**: Multiple ViewModels in one screen
3. **Mixed Responsibilities**: View and edit logic mixed together
4. **Maintainability**: 1800+ lines in single file
5. **Poor User Experience**: Tab-based editing is confusing
6. **Testing Complexity**: Hard to test individual components

### **ðŸŽ¯ Priority 1: Patient Screen Architecture Refactoring**

#### **Phase 1: Create Separate Patient Screens (Like Visits)**

**1.1 Create PatientDetailsScreen (View Only)**
```kotlin
PatientDetailsScreen(
    patientId: String,
    onBackClick: () -> Unit,
    onEditClick: () -> Unit
)
```
- Read-only display of all patient information
- Organized sections (Personal Data, Clinical History, etc.)
- Edit button that navigates to EditPatientScreen
- Clean, focused responsibility

**1.2 Create EditPatientScreen (Edit Only)**
```kotlin
EditPatientScreen(
    patientId: String,
    onBackClick: () -> Unit,
    onPatientUpdated: (Patient) -> Unit
)
```
- Comprehensive edit form for all patient data
- Single ViewModel (`EditPatientViewModel`)
- MVI pattern consistency
- Form validation and error handling

#### **Phase 2: Refactor ViewModels**

**2.1 Consolidate EditPatientViewModel**
- Merge `EditPatientViewModel` + `ClinicalHistoryViewModel` into one
- Handle all patient data editing in single ViewModel
- Use MVI pattern like `EditVisitViewModel`

**2.2 Create PatientDetailsViewModel (View Only)**
- Simple ViewModel for loading and displaying patient data
- No editing logic, just data fetching and presentation

#### **Phase 3: Update Navigation**

**3.1 Update Navigation Flow**
```kotlin
// Current: PatientDetailsScreen (complex tabs)
// New: 
PatientsScreen -> PatientDetailsScreen (view) -> EditPatientScreen (edit)
```

**3.2 Update Navigation Calls**
- Replace tab-based editing with screen navigation
- Consistent with visit editing pattern

#### **Phase 4: Component Extraction**

**4.1 Extract Reusable Components**
- `PatientInfoSection` (already exists)
- `PatientInfoRow` (already exists)
- `PatientEditForm` (extract from current screen)
- `ClinicalHistoryEditForm` (already exists)

**4.2 Create Shared Components**
- Common patient display components
- Reusable form components
- Consistent styling

#### **Phase 5: Testing & Validation**

**5.1 Unit Tests**
- Test each screen independently
- Test ViewModels separately
- Test navigation flow

**5.2 Integration Tests**
- Test complete patient editing workflow
- Test data persistence
- Test error handling

### **Benefits of This Refactoring:**

**Architectural Benefits:**
1. **Consistency**: Same pattern as visits (Details + Edit screens)
2. **Separation of Concerns**: View vs Edit responsibilities clearly separated
3. **Maintainability**: Smaller, focused files
4. **Testability**: Easier to test individual components

**User Experience Benefits:**
1. **Consistency**: Same editing pattern across the app
2. **Clarity**: Clear distinction between viewing and editing
3. **Performance**: Lighter screens, faster navigation
4. **Accessibility**: Better screen reader support

**Development Benefits:**
1. **Code Reuse**: Shared components between screens
2. **Debugging**: Easier to isolate issues
3. **Feature Addition**: Easier to add new patient features
4. **Team Development**: Multiple developers can work on different screens

### **Implementation Priority:**

1. **âœ… COMPLETED**: Create `PatientDetailsScreenNew` (view only) - **DONE**
2. **âœ… COMPLETED**: Create `EditPatientScreen` (edit only) - **DONE**
3. **Medium Priority**: Consolidate ViewModels
4. **Medium Priority**: Update navigation
5. **Low Priority**: Extract components and optimize

### **ðŸŽ¯ Priority 2: Search and Filtering Enhancement**
- **Patient Search**: Advanced search across patient fields (name, ID, phone, email)
- **Visit Search**: Search visits by date range, patient, osteopath, status
- **Filtering**: Filter visits by date, patient, treatment type, status
- **Quick Search**: Real-time search with debouncing for performance

### **ðŸŽ¯ Priority 3: Enhanced Visit Data Models**
- **Apparatus Evaluation**: Comprehensive system evaluation models (cranial, respiratory, cardiovascular, etc.)
- **Treatment Documentation**: Detailed treatment techniques, duration, recommendations
- **Pain Assessment**: VAS scale, pain characteristics, triggers, relieving factors
- **Follow-up Planning**: Next visit scheduling and treatment plans

### **ðŸŽ¯ Priority 4: Multi-Step Visit Forms**
- **Step 1**: Basic visit information (patient, date, osteopath)
- **Step 2**: Chief complaint and pain assessment
- **Step 3**: Apparatus evaluation (13 body systems)
- **Step 4**: Treatment documentation
- **Step 5**: Final evaluation and follow-up planning

### **ðŸŽ¯ Priority 5: Data Export and Backup**
- **JSON Export**: Export patient and visit data for backup
- **Data Migration**: Support for schema updates and data migration
- **Backup/Restore**: Complete data backup and restore functionality
- **Report Generation**: Generate visit reports and summaries

When generating code, prioritize:
- **Type Safety**: Use strong typing throughout the application
- **Maintainability**: Write clean, self-documenting code
- **Scalability**: Design for future feature additions
- **User Experience**: Focus on intuitive, efficient workflows for healthcare professionals